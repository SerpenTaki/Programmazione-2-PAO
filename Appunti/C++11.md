**Funtore**: oggetto che rappresenta una funzione -> *La posso usare come funzione, accentando parametri e restituendo valori*.

# Lambda espressioni
*alternativa ai funtori anonimi*.
Una labmda espressione (*o lambda funzione o funzione anonima*) consente di definire delle funzioni a livello locale, dove esse sono invocate, senza definire un identificatore. Una lambda espressione ha la seguente sintassi:
```C++
[capture list] (lista parametri) ->return-type {corpo}
```
dove `(lista parametri)` e `->return-type` sono opzionali. Se non vi sono parametri, le parentesi `()` possono essere omesse.
Il tipo di ritorno può essere omesso se il tipo di ritorno è `void` oppure se il corpo consiste di una unica istruzione `return` o se tutte le istruzioni di `return` ritornano espressioni dello stesso tipo.
```C++
[](int x, int y) {return x+y;} //tipo di ritorno implicito: int

[](int& x) {++x;} //tipo di ritorno implicito: void
```
Una lambda espressione può usare variabili le dichiarate al suo esterno , e l'insieme di tali variabili usate (*catturate*) viene detto anche *chiusura* (`closure`). Il costrutto `[capture list]`
elenca la lista delle variabili nella closure:
```
[] \\ nessuna variabile esterna catturata
[x, &y] \\ x catturata per valore, y per riferimento
[&] \\ tutte le variabili esterne catturate per riferimento
[=] \\ tutte le variabili esterne catturate per valore
[&, x] \\ tutte le variabili per riferimento, tranne x per valore
```
Si supponga di voler contare quante lettere maiuscole occorrono in una stringa:
Utilizzando il nuovo costrutto C++11 `for_each` *per scorrere gli elementi di un'array o stringa* definiamo una lambda espressione che determina se una lettera è in maiuscolo. Per ogni lettera in maiuscolo trovata la lambda espressione incrementa la variabile `Uppercase`definita esternamente. La lambda espressione non ha tipo di ritorno esplicito, che è quindi implicitamente void.
```C++
int main() {
 char s[] = 'Hello World!';
 int Uppercase = 0; //modificata dalla lambda espressione
 for_each(s, s+sizeof(s), [&Uppercase] (char c) {
	 if (isupper(c)) Uppercase++;
	 });
 cout << Uppercase << " lettere maiuscole in: " << s << endl;
}
```
Si tratta quindi della definizione di una funzione anonima definita dentro un'altra funzione. La notazione `[&Uppercase]` ottiene un riferimento alla variabile esterna `Uppercase` che permette quindi alla lambda espressione di modificarla.
*Esempio*:
```C++
vector<int> v = {50, -10, 20, -30};

//sort di default
std::sort(v.begin(), v.end());
//v diventa { -30, -10, 20, 50 }

//sort per valore assoluto
std::sort(v.begin(), v.end(), [] (int a, int b) {
	return abs(a)<abs(b);
	});
// v diventa { -10, 20, -30, 50 }
```
Infine consideriamo il seguente esempio:
```C++
std::vector<int> v = {6,2,-1,0,6};
int totale = 0; int a = 5;
std::for_each(v.begin(), v.end(), [&, a, this] (int x){
	totale += x * a * this->somefunction();
	});
```
Si noti che `totale` può essere modificata perchè catturata per riferimento nella chiusura, mentre la variabile `a` è (giustamente) catturata per valore. Osserviamo inoltre che il puntatore `this` viene catturato per valore, e questo è l'unico modo in cui è possibile catturarlo in una lambda espressione. Ovviamente `this` può essere catturato se la lambda espressione viene definita nel corpo di qualche metodo di istanza, ossia in un blocco dove è definito il puntatore `this`.

# Riferimenti rvalue
